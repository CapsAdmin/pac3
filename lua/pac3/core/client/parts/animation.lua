local FrameTime = FrameTime


local PART = {}

PART.ClassName = "animation"
PART.NonPhysical = true
PART.ThinkTime = 0

PART.frame = 0

pac.StartStorableVars()
	pac.GetSet(PART, "Loop", true)
	pac.GetSet(PART, "PingPongLoop", false)
	pac.GetSet(PART, "SequenceName", "")
	pac.GetSet(PART, "Rate", 1)
	pac.GetSet(PART, "Offset", 0)
	pac.GetSet(PART, "Min", 0)
	pac.GetSet(PART, "Max", 1)
	pac.GetSet(PART, "WeaponHoldType", "none")
	pac.GetSet(PART, "OwnerCycle", false)
	pac.GetSet(PART, "ResetOnHide", true)
pac.EndStorableVars()


local tonumber = tonumber

PART.ValidHoldTypes =
{
	pistol = ACT_HL2MP_IDLE_PISTOL,
	smg = ACT_HL2MP_IDLE_SMG1,
	grenade = ACT_HL2MP_IDLE_GRENADE,
	ar2 = ACT_HL2MP_IDLE_AR2,
	shotgun = ACT_HL2MP_IDLE_SHOTGUN,
	rpg = ACT_HL2MP_IDLE_RPG,
	physgun = ACT_HL2MP_IDLE_PHYSGUN,
	crossbow = ACT_HL2MP_IDLE_CROSSBOW,
	melee = ACT_HL2MP_IDLE_MELEE,
	slam = ACT_HL2MP_IDLE_SLAM,
	normal = ACT_HL2MP_IDLE,
	fist = ACT_HL2MP_IDLE_FIST,
	melee2 = ACT_HL2MP_IDLE_MELEE2,
	passive = ACT_HL2MP_IDLE_PASSIVE,
	knife = ACT_HL2MP_IDLE_KNIFE,
	duel = ACT_HL2MP_IDLE_DUEL,
	camera = ACT_HL2MP_IDLE_CAMERA,
	revolver = ACT_HL2MP_IDLE_REVOLVER,

	zombie = ACT_HL2MP_IDLE_ZOMBIE,
	magic = ACT_HL2MP_IDLE_MAGIC,
	meleeangry = ACT_HL2MP_IDLE_MELEE_ANGRY,
	angry = ACT_HL2MP_IDLE_ANGRY,
	suitcase = ACT_HL2MP_IDLE_SUITCASE,
	scared = ACT_HL2MP_IDLE_SCARED,
}

function PART:GetNiceName()
	local str = self:GetSequenceName()

	if str == "" and self:GetWeaponHoldType() ~= "none" then
		str = self:GetWeaponHoldType()
	end

	return pac.PrettifyName(str)
end

function PART:GetOwner()
	local parent = self:GetParent()

	if parent:IsValid() and parent.ClassName == "model" and parent.Entity:IsValid() then
		return parent.Entity
	end

	return self.BaseClass.GetOwner(self)
end
function PART:GetSequenceList()
	local ent = self:GetOwner()

	if ent:IsValid() then
		return ent:GetSequenceList()
	end
	return {"none"}
end

PART.GetSequenceNameList = PART.GetSequenceList

function PART:OnHide()
	local ent = self:GetOwner()

	if ent:IsValid() then
		if ent.pac_animation_sequences then
			ent.pac_animation_sequences[self] = nil
		end

		if ent.pac_animation_holdtypes then
			ent.pac_animation_holdtypes[self] = nil
		end

		if not ent:IsPlayer() and self:GetResetOnHide() then
			ent:SetSequence(0)
		end
	end
end

PART.random_seqname = ""

function PART:SetSequenceName(name)
	self.SequenceName = name
	self.random_seqname = table.Random(name:Split(";"))

	if not self:IsHidden() then
		self:OnShow()
	end
end

function PART:OnShow()
	local ent = self:GetOwner()

	if ent:IsValid() then
		self.random_seqname = table.Random(self.SequenceName:Split(";"))

		if self.random_seqname ~= "" then
			local seq = ent:LookupSequence(self.random_seqname)

			local count = ent:GetSequenceCount()

			if seq < 0 or seq > count or count < 0 then
				return
			end

			ent.pac_animation_sequences = ent.pac_animation_sequences or {}
			ent.pac_animation_sequences[self] = ent.pac_animation_sequences[self] or {}

			local tbl = ent.pac_animation_sequences[self]

			tbl.part = self

			if seq ~= -1 then
				tbl.seq = seq
			else
				seq = tonumber(self.random_seqname) or -1

				if seq ~= -1 then
					tbl.seq = seq
				else
					ent.pac_animation_sequences[self] = nil
				end
			end

			if seq ~= -1  then
				ent:SetSequence(seq)
			end

		elseif ent:IsPlayer() then
			local t = self.WeaponHoldType
			t = t:lower()

			local index = self.ValidHoldTypes[t]

			ent.pac_animation_holdtypes = ent.pac_animation_holdtypes or {}

			if index == nil then
				ent.pac_animation_holdtypes[self] = nil
			else
				local params = {}
					params[ACT_MP_STAND_IDLE] = index + 0
					params[ACT_MP_WALK] = index + 1
					params[ACT_MP_RUN] = index + 2
					params[ACT_MP_CROUCH_IDLE] = index + 3
					params[ACT_MP_CROUCHWALK] = index + 4
					params[ACT_MP_ATTACK_STAND_PRIMARYFIRE]	= index + 5
					params[ACT_MP_ATTACK_CROUCH_PRIMARYFIRE] = index + 5
					params[ACT_MP_RELOAD_STAND] = index + 6
					params[ACT_MP_RELOAD_CROUCH] = index + 7
					params[ACT_MP_JUMP] = index + 8
					params[ACT_RANGE_ATTACK1] = index + 9
					params[ACT_MP_SWIM_IDLE] = index + 10
					params[ACT_MP_SWIM] = index + 11

				-- "normal" jump animation doesn't exist
				if t == "normal" then
					params[ACT_MP_JUMP] = ACT_HL2MP_JUMP_SLAM
				end

				-- these two aren't defined in ACTs for whatever reason
				if t == "knife" or t == "melee2" then
					params[ACT_MP_CROUCH_IDLE] = nil
				end

				params.part = self

				ent.pac_animation_holdtypes[self] = params
			end
		end
	end
end

function PART:OnThink()
	local ent = self:GetOwner()

	if ent:IsValid() then
		if not self.random_seqname then return end

		local seq = ent:LookupSequence(self.random_seqname)

		local duration = 0
		local count = ent:GetSequenceCount()
		if seq >= 0 and seq < count and count > 0 then
			duration = ent:SequenceDuration(seq)
		else
			-- It's an invalid sequence. Don't bother
			return
		end

		if self.OwnerCycle then
			local owner = self.BaseClass.GetOwner(self, true)
			ent:SetCycle(owner:GetCycle())
			return
		end

		local rate = math.min(self.Rate * duration, 1)

		if seq ~= -1 then

			if rate == 0 then
				ent:SetCycle(self.Offset % 1)
				return
			end
		else
			seq = tonumber(self.random_seqname) or -1

			if seq ~= -1 then
				if rate == 0 then
					ent:SetCycle(self.Offset % 1)
					return
				end
			else
				return
			end
		end

		rate = rate / math.abs(self.Min - self.Max)
		rate = rate * FrameTime()

		local min = self.Min
		local max = self.Max

		if self.PingPongLoop then
			self.frame = self.frame + rate / 2
			local cycle = min + math.abs(math.Round((self.frame + self.Offset) * 0.5) - (self.frame + self.Offset) * 0.5) * 2 * (max - min)
			if pac.IsNumberValid(cycle) then
				ent:SetCycle(cycle)
			end
		else
			self.frame = self.frame + rate
			local cycle = min + ((self.frame + self.Offset) * 0.5) % 1 * (max - min)
			if pac.IsNumberValid(cycle) then
				ent:SetCycle(cycle)
			end
		end
	end
end

pac.RegisterPart(PART)